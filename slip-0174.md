# SLIP-0174 : Deterministic key hierarchy for BLS-12381 curve

```
Number:  SLIP-0174
Title:   Deterministic key hierarchy for BLS-12381 curve
Type:    Standard
Status:  Draft
Authors: Mostafa Sedaghat Joo <mostafa.sedaghat@gmail.com>
Created: 2022-08-27
```

## Abstract

This document describes hierarchical deterministic wallets (or "HD Wallets") for BLS signature schema.

## Motivation

The hierarchical deterministic key derivation is not standardized for BLS signature schema.
Since BLS is widely used in many projects, having the hierarchical deterministic is ideal.
This document proposes a standard to generate HD key chains for BLS signature schema.

## Conventions

We assume:

* c: represents the chain code to derive the child key.
* P1: represents a point in G1 subgroup.
* P2: represents a point in G2 subgroup.
* point_G1(p): returns the point in E1 curve resulting from EC point multiplication of the **G1 base point** with the integer p.
* point_G2(p): returns the point in E2 curve resulting from EC point multiplication of the **G2 base point** with the integer p.
* ser<sub>32</sub>(i): serialize a 32-bit unsigned integer i as a 4-byte sequence, most significant byte first.
* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.
* ser<sub>E1</sub>(P1): serializes the point P1 as 48-byte sequence, most significant byte first.
* ser<sub>E2</sub>(P2): serializes the point P2 as 96-byte sequence, most significant byte first.
* parse<sub>256</sub>(p): interprets a 32-byte sequence as a 256-bit number, most significant byte first.

## Child key derivation (CKD) functions

In BLS signature, the public key can be defined either on G1 or G2 subgroups.
For hardened key derivation, the result of key derivation is the same in both cases.
However for non-hardened derivations it is not the same.
Based on which curve the public key is defined, the private key will be different.
It makes sense since the private key in non hardened is the result of hashing the public key and child index.

### Private parent key &rarr; private child key

The function CKDpriv((k<sub>par</sub>, c<sub>par</sub>), i) &rarr; (k<sub>i</sub>, c<sub>i</sub>) computes a child extended private key from the parent extended private key:
* Check whether i ≥ 2<sup>31</sup> (whether the child is a hardened key).
  + If so (hardened child): let I = HMAC-SHA512(Key = c<sub>par</sub>, Data = ser<sub>256</sub>(k<sub>par</sub>) || ser<sub>32</sub>(i)).
  + If not (normal child):
    - If public key is in G1: let I = HMAC-SHA512(Key = c<sub>par</sub>, Data = ser<sub>E1</sub>(point_G1(k<sub>par</sub>)) || ser<sub>32</sub>(i)).
    - If public key is in G2: let I = HMAC-SHA512(Key = c<sub>par</sub>, Data = ser<sub>E2</sub>(point_G2(k<sub>par</sub>)) || ser<sub>32</sub>(i)).
* Split I into two 32-byte sequences, I<sub>L</sub> and I<sub>R</sub>.
* The returned child key k<sub>i</sub> is parse<sub>256</sub>(I<sub>L</sub>) + k<sub>par</sub> (mod n).
* The returned chain code c<sub>i</sub> is I<sub>R</sub>.
* In case k<sub>i</sub> = 0, the resulting key is invalid, and one should proceed with the next value for i.

### Public parent key &rarr; public child key

The function CKDpub((K<sub>par</sub>, c<sub>par</sub>), i) &rarr; (K<sub>i</sub>, c<sub>i</sub>) computes a child extended public key from the parent extended public key. It is only defined for non-hardened child keys.
* Check whether i ≥ 2<sup>31</sup> (whether the child is a hardened key).
  + If so (hardened child): return failure
  + If not (normal child):
    - If public key is in G1: let I = HMAC-SHA512(Key = c<sub>par</sub>, Data = ser<sub>E1</sub>(K<sub>par</sub>) || ser<sub>32</sub>(i)).
    - If public key is in G2: let I = HMAC-SHA512(Key = c<sub>par</sub>, Data = ser<sub>E2</sub>(K<sub>par</sub>) || ser<sub>32</sub>(i)).
* Split I into two 32-byte sequences, I<sub>L</sub> and I<sub>R</sub>.
* The returned child key K<sub>i</sub> is point_G1(parse<sub>256</sub>(I<sub>L</sub>)) + K<sub>par</sub>.
* The returned chain code c<sub>i</sub> is I<sub>R</sub>.
* In case K<sub>i</sub> is the point at infinity, the resulting key is invalid, and one should proceed with the next value for i.


## Test vectors

Seed (hex): 000102030405060708090a0b0c0d0e0f
* Chain m
  + ext prv on G1: 38167a7b6fcea7929deb6af40123e37b2ef21e488f4871f16d411914490657f5
  + ext prv on G2: 38167a7b6fcea7929deb6af40123e37b2ef21e488f4871f16d411914490657f5
  + ext pub on G1: b99b512321d9dbae271f4d418b10a2345fa84c1c883d0f9a82163b84c405948ea123f01141258cdbed2d033eae4a551a
  + ext pub on G2: 			97167b36223b32c3b0b8c8234eefeeee12a37b3aafa9ed4e156facd2d5a4206d72f814bd69270ae0a95d6de13f1a1e6618330e1d02506ed8ec2c184660912213bf2cd54f66b38fe3e5dd241320cf2684f6c86affd93a07689870dedeb6cf133b
* Chain m/0<sub>H</sub>
  + ext prv on G1: 0da9a671ff3cc10514fa9cf8368af0756ad01e242bb3ae4d06a4061e6c3ec6be
  + ext prv on G2: 0da9a671ff3cc10514fa9cf8368af0756ad01e242bb3ae4d06a4061e6c3ec6be
  + ext pub on G1: ad880d92cb1276c8d5768d26dcc3ebf23de4f0a1d12c9b99fdb6b745ff931d2c01925b4fec4147d7452faddc18564b98
  + ext pub on G2: b5bfa5aa0ee3c8c4f9222f4f244c3fd6fddcdd0accf484e56d09c70a4e2eada059073c890bbfc30d2693a8a68262c3ac06da94222f5d9de2b8ea4fb7cf29664196becd7a36f49a55f9364afe2536de909b87a8c2900cd38590f8dd4b51c8642a
* Chain m/0<sub>H</sub>/1
  + ext prv on G1: 0f356ce1bc5fd0d8c6ac274c7b206c2cb868b502af7a7065e836ca28f0d865a5
  + ext prv on G2: 647e9be74b8648a198267e18c40d988b74f1ff8a33132fb012187ffd22c96fc4
  + ext pub on G1: 92c9d3908b636a383c174bd3d27a8ae5b116240b90aa4d4b2425405b11eded72419284f04c66438578adffbc62e3698d
  + ext pub on G2: ae08105f86d96658083e0799bb2fa282f6431a7d23044ef6aaf3083b027aaed32798005e27668a7327e36a7db07fcab40253921fe842ba2b7411a44bfd292c7cf124970b70da554fceff6eef4ba2edddeb713d40bebbd79c24b9888541da63a3
* Chain m/0<sub>H</sub>/1/2<sub>H</sub>
  + ext prv on G1: 1f8dd29cf00257ffd4bc4001580d2011ce23a0727ce20ee4156c7a6fb61964ce
  + ext prv on G2: 578d64b2246b6b8c8906073b2de5cad50313997206ba872d38886d3d2d5eb508
  + ext pub on G1: 93981a7ebf6ec8ffe6a5be1a4dfda93c8e9b192f79417ba5d4c4590c034306666ae3408146c33325ed8bab3fc0b01926
  + ext pub on G2: a89393efab309f3be02e501ebb6f472ef6392d48f832289247992497f4da816dfefc89fccf8b423b6e3005f7f29cdbf305c4aa0bd6163ece7d816dd34d83193512f17a752fb1a64b7e6455b7e301dcddf4eab0170304a1398d53abaabc63bdce
* Chain m/0<sub>H</sub>/1/2<sub>H</sub>/2
  + ext prv on G1: 1ff1c89c8ac0387cb6b66d79c3da6b4bdc400d991d71ae78aa569e8d005d84ae
  + ext prv on G2: 22d2d08809f4fe0103b1b4750565da52147d8694c6c382320a988368ea0fe14c
  + ext pub on G1: 8eec88f3d3dd95b6d234ca83a9862989c3b960196a482d7c81eafd207faf60acac5624101184394a9dd4a7848115320e
  + ext pub on G2: aabdc2a56f89fce40ee071dc3193aa63784391930af044258d3e104bdc9b2bef9aacb310466bada59df534c46cb6cfa2073e2c7c1e92905cba9d55bc32316ccfc2b71ac00fa75ed26098f301475a3dcf8fa5793b49aa6f538dd74873a5ca8baa
* Chain m/0<sub>H</sub>/1/2<sub>H</sub>/2/1000000000
  + ext prv on G1: 3475af3ba6a3dbb5c181d9be4eaf0bea3ba6d1493a7a028978b563acd0799a67
  + ext prv on G2: 4a19cfe432a510604ca9e6cdfda424e021f477ebbdd7e4130c01d32d567a92ee
  + ext pub on G1: 860c0f97c1e8ed8d8c0265898e872428a4d6f33a10700e26a2536a333a6a5579029e9dd870c3801867667dba6b750fff
  + ext pub on G2: b12f350aaa1d66451a8a6fedc1bbcd3d3895808b7788d09e9c5d14d91a05e4c983e0fdbffa3a2afa393528b9cbbb49090880ef251db20a6d671f00a82afa8cba5ba5964a1cf96c8592751dc65c38c268d2bf1bcdfd88aab585c21a96dfa4ba6f

## Implementation

* [Go implementation](https://github.com/pactus-project/pactus/tree/main/crypto/bls/hdkeychain)

## References

* [BIP-0032: Hierarchical Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
* [BLS Signature](https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/)
